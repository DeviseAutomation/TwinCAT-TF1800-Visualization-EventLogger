<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{780b1aba-d03f-4a0d-ae4b-528d03a6a31d}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	DevState AT %I*			: UINT;
	fbReadEvents			: FB_ReadTc3Events; // Required for Event Table Visu Control
	fbMachineAlarm			: ARRAY[0..100] OF FB_AlarmEx;
	fbMachineMessage		: ARRAY[0..100] OF FB_Message;
	TestAlarm				: ARRAY[1..10] OF BOOL;
	TestMessage				: ARRAY[1..10] OF BOOL;
	
	
	Fault 					: ARRAY [1..100] OF BOOL;
	fbAlarmLogEvent 		: ARRAY [1..100] OF FB_AlarmLogEvent_TextList; //Alarm Logging Event Handler
	fbAlarmLogEventTable	: ARRAY [1..100] OF FB_AlarmLogEvent_Table; //Alarm Logging Event Handler
	iFaultIndex				: INT;
	iAlarmClearIndex		: INT;
	iAlarmActiveIndex		: INT;
	iAlarmActiveIndex2		: INT;
	diAlarmEventLogIndex	: DINT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Get Local System Time
	SYS.fbGetLocalSystemTIme( 
		bEnable:= TRUE, 
		dwCycle:= 1);
	//Seperate Date and time
		SYS.sSystemDateTime := SYSTEMTIME_TO_STRING(in:= SYS.fbGetLocalSystemTIme.systemTime);
		SYS.sSystemDate := MID(STR:= SYS.sSystemDateTime, LEN:= 10 , POS:= 1 );
		SYS.sSystemTime := MID(STR:= SYS.sSystemDateTime, LEN:= 8 , POS:= 12 );

// HMI Fault PB Passthrough		
SYS.xFaultReset := HMI.xFaultResetPB;
	
// Twincat Event Logger	
// The function block enables the events of the TwinCAT 3 EventLogger to be displayed in the visualization element event table. 
// FB_ReadTc3Events is contained in the VisuElemEventTable library, which is automatically added to the project when the event table is activated
fbReadEvents(
	bReadEvents := TRUE,		// This input is used to enable the events to be read.
	nLanguageID := ,			// Defines which translation of the event text is to be retrieved.
	eDateAndTimeFormat := ,		// Defines the format of the timestamps. E_DateAndTimeFormat
	bClearTable := ,			// The event table is cleared via a positive edge at this input. Alarms that were not acknowledged or reset are not removed from the table.
	eMinSeverity := ,			// Only events whose severity is at least as high as the severity specified here are displayed in the event table.
	aEvents => ,				// The function block uses this array to make the evaluated events available. The array can store a maximum of 80 messages. If the number of events is large, older messages are overwritten.
	nNumberOfEvents => ,		// Indicates how many events were triggered.
	bError => ,					// This output is set if an error occurs when polling or processing the events.
	hrErrorCode => );			// Indicates the error code of the error that has occurred.
	
Tc3_EventLogger();

// Legacy Alarm List
A99_Alarms_TextList();
A99_Alarms_Table();

// First Scan Complete
SYS.xFirstScan := FALSE;]]></ST>
    </Implementation>
    <Action Name="A99_Alarms_Table" Id="{964fc8f7-596d-4e3c-b741-2a318ba4dda6}">
      <Implementation>
        <ST><![CDATA[//System Faults
	//Power Interrupted Fault							
		fbAlarmLogEventTable[1](
							i_diEventID:= 1,							// Must match the AlarmText Index for the message to display
							sEventText := 'Power Interrupt Fault',		// Enter an Event String Here
							i_iClassID:= 7,								// 0 = none, 1= Maintenance, 2= Message, 3= Hint, 4= StateInfo, 5= Instruction, 6 = Warning, 7= Alarm, 8= Paramater		
							bSetEvent := SYS.xFirstScan,				// Event activates on rising edge, clears on falling edge
							bLatchTillAck:= TRUE,						// Option to Latch alarm on even if no longer active, wait till alarm ack to clear
							bAck:= SYS.xFaultReset);					// Acknowledged and clears on rising edge if option LatchTillAck = false
							

		fbAlarmLogEventTable[2](
							i_diEventID:= 2,
							sEventText := 'Test Alarm 1',
							i_iClassID:= 7,
							bSetEvent := TestAlarm[1],
							bLatchTillAck:= TRUE,
							bAck:= SYS.xFaultReset);
							

		fbAlarmLogEventTable[3](
							i_diEventID:= 3,
							sEventText := 'Test Alarm 2',
							i_iClassID:= 2,
							bSetEvent := TestAlarm[2],
							bLatchTillAck:= TRUE,
							bAck:= SYS.xFaultReset);
							
					
		fbAlarmLogEventTable[4](
							i_diEventID:= 4,
							sEventText := 'Test Alarm 3',
							i_iClassID:= 6,
							bSetEvent := TestAlarm[3],
							bLatchTillAck:= TRUE,
							bAck:= SYS.xFaultReset);
							
				
		fbAlarmLogEventTable[5](
							i_diEventID:= 5,
							sEventText := 'Test Alarm 4',
							i_iClassID:= 7,
							bSetEvent := TestAlarm[4],
							bLatchTillAck:= TRUE,
							bAck:= SYS.xFaultReset);


// iClassID : 0 = none, 1= Maintenance, 2= Message, 3= Hint, 4= StateInfo, 5= Instruction, 6 = Warning, 7= Alarm, 8= Paramater	
//Monitor Fault Present
FOR iFaultIndex := 1 TO 100 BY 1 DO
	//System
	IF (iFaultIndex > 0) AND (iFaultIndex < 20) THEN // Look at Alarm Group 1-20
		IF fbAlarmLogEventTable[iFaultIndex].q_xActive AND (fbAlarmLogEventTable[iFaultIndex].i_iClassID = 7) THEN // Only Class 7 Count as Alarms
			SYS.xFaultPresent := TRUE;
		END_IF
	END_IF
	
(*  Some Other Alarm Group
	IF (iFaultIndex >= 20) AND (iFaultIndex < 40) THEN // Subsequent Alarm Group
		IF fbAlarmLogEvent[iFaultIndex].q_xActive AND (fbAlarmLogEvent[iFaultIndex].i_iClassID = 7) THEN
			OtherMachineFaultPreset := TRUE;
		END_IF
	END_IF
*)
END_FOR

// System Fault to HMI Fault Indicator
HMI.xFaultPresent := SYS.xFaultPresent;

IF SYS.xFaultReset THEN
	SYS.xFaultPresent := FALSE;
END_IF

(* Log all Alarms using the fbAlarmLogEvent function block*)
(* Alarm Text is in the Alarm_TextList File*)	

//Clear active alarms list before re-populating to ensure old cleared alarms are not stranded in the list
IF SYS.xFaultReset THEN
	FOR iAlarmClearIndex := 1 TO 50 BY 1 DO //10 possible active Alarms, no more!
		HMI.astActiveAlarmsTable[iAlarmClearIndex].sEvent := '';
		HMI.astActiveAlarmsTable[iAlarmClearIndex].diEventID := 0;
		HMI.astActiveAlarmsTable[iAlarmClearIndex].iClass := 0;
		HMI.astActiveAlarmsTable[iAlarmClearIndex].sTime := '';
	END_FOR;
END_IF
	
//Populate HMI Active Alarms list
	iAlarmActiveIndex2 := 0;  //Initialize before seeing how many active alarms there are.
	FOR diAlarmEventLogIndex := 1 TO 100 BY 1 DO //100 possible defined Alarms, no more!
		IF fbAlarmLogEvent[diAlarmEventLogIndex].q_xActive THEN
			IF iAlarmActiveIndex2 <= 9 THEN //10 max active alarms, no more!
				iAlarmActiveIndex2 := iAlarmActiveIndex2 + 1;
			END_IF
			HMI.astActiveAlarmsTable[iAlarmActiveIndex2].sEvent := fbAlarmLogEventTable[diAlarmEventLogIndex].q_stAlarmEventData.sEvent;
			HMI.astActiveAlarmsTable[iAlarmActiveIndex2].diEventID := fbAlarmLogEventTable[diAlarmEventLogIndex].q_stAlarmEventData.diEventID;
			HMI.astActiveAlarmsTable[iAlarmActiveIndex2].iClass := fbAlarmLogEventTable[diAlarmEventLogIndex].q_stAlarmEventData.iClass;
			IF HMI.astActiveAlarmsTable[iAlarmActiveIndex2].sTime = '' THEN
				HMI.astActiveAlarmsTable[iAlarmActiveIndex2].sTime := SYS.sSystemTime;
			END_IF
		END_IF
	END_FOR;					]]></ST>
      </Implementation>
    </Action>
    <Action Name="A99_Alarms_TextList" Id="{e6808c4c-dd4f-4e4a-b903-fa553d80dc42}">
      <Implementation>
        <ST><![CDATA[//System Faults
	//Power Interrupted Fault
		fbAlarmLogEvent[1](i_diEventID:= 1,					// Must match the AlarmText Index for the message to display
							i_iClassID:= 7,					// 0 = none, 1= Maintenance, 2= Message, 3= Hint, 4= StateInfo, 5= Instruction, 6 = Warning, 7= Alarm, 8= Paramater		
							bSetEvent := SYS.xFirstScan,	// Event activates on rising edge, clears on falling edge
							bLatchTillAck:= TRUE,			// Option to Latch alarm on even if no longer active, wait till alarm ack to clear
							bAck:= SYS.xFaultReset);		// Acknowledged and clears on rising edge if option LatchTillAck = false
							

		fbAlarmLogEvent[2](i_diEventID:= 2,
							i_iClassID:= 7,
							bSetEvent := TestAlarm[1],
							bLatchTillAck:= TRUE,
							bAck:= SYS.xFaultReset);
							

		fbAlarmLogEvent[3](i_diEventID:= 3,
							i_iClassID:= 2,
							bSetEvent := TestAlarm[2],
							bLatchTillAck:= TRUE,
							bAck:= SYS.xFaultReset);
							
					
		fbAlarmLogEvent[4](i_diEventID:= 4,
							i_iClassID:= 6,
							bSetEvent := TestAlarm[3],
							bLatchTillAck:= TRUE,
							bAck:= SYS.xFaultReset);
							
				
		fbAlarmLogEvent[5](i_diEventID:= 5,
							i_iClassID:= 7,
							bSetEvent := TestAlarm[4],
							bLatchTillAck:= TRUE,
							bAck:= SYS.xFaultReset);


// iClassID : 0 = none, 1= Maintenance, 2= Message, 3= Hint, 4= StateInfo, 5= Instruction, 6 = Warning, 7= Alarm, 8= Paramater	
//Monitor Fault Present
FOR iFaultIndex := 1 TO 100 BY 1 DO
	//System
	IF (iFaultIndex > 0) AND (iFaultIndex < 20) THEN // Look at Alarm Group 1-20
		IF fbAlarmLogEvent[iFaultIndex].q_xActive AND (fbAlarmLogEvent[iFaultIndex].i_iClassID = 7) THEN // Only Class 7 Count as Alarms
			SYS.xFaultPresent := TRUE;
		END_IF
	END_IF
	
(*  Some Other Alarm Group
	IF (iFaultIndex >= 20) AND (iFaultIndex < 40) THEN // Subsequent Alarm Group
		IF fbAlarmLogEvent[iFaultIndex].q_xActive AND (fbAlarmLogEvent[iFaultIndex].i_iClassID = 7) THEN
			OtherMachineFaultPreset := TRUE;
		END_IF
	END_IF
*)
END_FOR

// System Fault to HMI Fault Indicator
HMI.xFaultPresent := SYS.xFaultPresent;

IF SYS.xFaultReset THEN
	SYS.xFaultPresent := FALSE;
END_IF

(* Log all Alarms using the fbAlarmLogEvent function block*)
(* Alarm Text is in the Alarm_TextList File*)	

//Clear active alarms list before re-populating to ensure old cleared alarms are not stranded in the list
IF SYS.xFaultReset THEN
	FOR iAlarmClearIndex := 0 TO 10 BY 1 DO //10 possible active Alarms, no more!
		HMI.astActiveAlarmsList[iAlarmClearIndex].diEventID := 0;
		HMI.astActiveAlarmsList[iAlarmClearIndex].iClass := 0;
		HMI.astActiveAlarmsList[iAlarmClearIndex].sTime := '';
	END_FOR;
END_IF
	
//Populate HMI Active Alarms list
	iAlarmActiveIndex := 0;  //Initialize before seeing how many active alarms there are.
	FOR diAlarmEventLogIndex := 1 TO 100 BY 1 DO //100 possible defined Alarms, no more!
		IF fbAlarmLogEvent[diAlarmEventLogIndex].q_xActive THEN
			IF iAlarmActiveIndex <= 9 THEN //10 max active alarms, no more!
				iAlarmActiveIndex := iAlarmActiveIndex + 1;
			END_IF
			HMI.astActiveAlarmsList[iAlarmActiveIndex].diEventID := fbAlarmLogEvent[diAlarmEventLogIndex].q_stAlarmEventData.diEventID;
			HMI.astActiveAlarmsList[iAlarmActiveIndex].iClass := fbAlarmLogEvent[diAlarmEventLogIndex].q_stAlarmEventData.iClass;
			IF HMI.astActiveAlarmsList[iAlarmActiveIndex].sTime = '' THEN
				HMI.astActiveAlarmsList[iAlarmActiveIndex].sTime := SYS.sSystemTime;
			END_IF
		END_IF
	END_FOR;					]]></ST>
      </Implementation>
    </Action>
    <Action Name="TC3_EventLogger" Id="{19e1a384-3d6f-4959-911c-184c6d8d0c38}">
      <Implementation>
        <ST><![CDATA[// Event Classes are created in System -> Type System -> Event Class
// Write Click and Create your new Event Class.

fbMachineMessage[1](
	evtEntry:= TC_EVENTS.Test_EventClass.Test_Message1, 
	bEvt:= TestMessage[1]);
	
fbMachineMessage[2](
	evtEntry:= TC_EVENTS.Test_EventClass.Test_Message2, 
	bEvt:= TestMessage[2]);
	
fbMachineMessage[3](
	evtEntry:= TC_EVENTS.Test_EventClass.Test_Message3, 
	bEvt:= TestMessage[3]);
	
fbMachineMessage[4](
	evtEntry:= TC_EVENTS.Test_EventClass.Test_Message4, 
	bEvt:= TestMessage[4]);
	
fbMachineMessage[5](
	evtEntry:= TC_EVENTS.Test_EventClass.Test_Message5, 
	bEvt:= TestMessage[5]);
	
fbMachineAlarm[1](
	evtEntry:= TC_EVENTS.Test_EventClass.PowerInterrupt, 
	bEvt:= SYS.xFirstScan,
	bConfirm := SYS.xFaultReset); 
	
fbMachineAlarm[2](
	evtEntry:= TC_EVENTS.Test_EventClass.Test_Event1, 
	bEvt:= TestAlarm[1],
	bConfirm := SYS.xFaultReset); 
	
fbMachineAlarm[3](
	evtEntry:= TC_EVENTS.Test_EventClass.Test_Event2, 
	bEvt:= TestAlarm[2],
	bConfirm := SYS.xFaultReset); 
	
fbMachineAlarm[4](
	evtEntry:= TC_EVENTS.Test_EventClass.Test_Event3, 
	bEvt:= TestAlarm[3],
	bConfirm := SYS.xFaultReset); 
	
fbMachineAlarm[5](
	evtEntry:= TC_EVENTS.Test_EventClass.Test_Event4, 
	bEvt:= TestAlarm[4],
	bConfirm := SYS.xFaultReset); ]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>